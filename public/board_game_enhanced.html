<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6x7 Board Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        
        .game-container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(6, 70px);
            grid-template-rows: repeat(7, 70px);
            gap: 2px;
            margin: 20px auto;
            border: 2px solid #333;
            background-color: #8B4513;
            padding: 10px;
        }
        
        .cell {
            width: 70px;
            height: 70px;
            background-color: #DEB887;
            border: 1px solid #8B4513;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            font-size: 10px;
            font-weight: bold;
        }
        
        .cell.middle-row {
            background-color: #B8860B;
        }
        
        .cell.highlighted {
            background-color: #90EE90;
        }
        
        .cell.selected {
            background-color: #FFD700;
        }
        
        .cell.attack-range {
            background-color: #FFB6C1;
        }
        
        .piece {
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
        }
        
        .player1 {
            color: #CC0000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .player2 {
            color: #0066CC;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        .health-bar {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 6px;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa00 50%, #44ff44 100%);
            transition: width 0.3s ease;
            border-radius: 3px;
        }
        
        .ammo-counter {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: #333;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .replenished-indicator {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #4CAF50;
            color: white;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .current-player {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .phase-info {
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .placement-counter {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .turn-actions {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }
        
        .phase-requirement {
            font-size: 12px;
            color: #ff6600;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        .piece-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .piece-button {
            padding: 8px 12px;
            border: 2px solid #333;
            background-color: #f9f9f9;
            cursor: pointer;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .piece-button.selected {
            background-color: #FFD700;
        }
        
        .piece-button.disabled {
            background-color: #ccc;
            color: #666;
            cursor: not-allowed;
        }
        
        .end-turn-btn {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        
        .end-turn-btn:hover {
            background-color: #45a049;
        }
        
        .end-turn-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .piece-counts {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            font-size: 12px;
        }
        
        .player-pieces {
            border: 1px solid #333;
            padding: 10px;
            border-radius: 5px;
        }
        
        .error-message {
            color: #ff0000;
            font-size: 14px;
            margin: 10px 0;
            font-weight: bold;
        }
        
        .placement-zones {
            font-size: 12px;
            margin: 10px 0;
            color: #555;
        }
    </style>
</head>
<body>
    <!-- 
    =============================================================================
    6x7 TACTICAL BOARD GAME
    =============================================================================
    
    GAME OVERVIEW:
    - Turn-based tactical game on a 6x7 grid
    - Two phases: Placement Phase (2 turns each) and Battle Phase
    - Players must MOVE FIRST, then can attack (enforced rule)
    - Win condition: Defeat enemy General
    
    PIECE TYPES & STATS:
    - General (♔): 3 HP, 1 damage, standard movement
    - Cavalry (♘): 2 HP, 1 damage (2 on charge), can move 1-2 spaces
    - Heavy Infantry (⚔️): 3 HP, 1 damage, immune to cavalry charge
    - Light Infantry (🗡️): 2 HP, 1 damage, standard movement
    - Archer (🏹): 2 HP, 1 damage, 3 ammo, ranged attacks
    
    SPECIAL MECHANICS:
    - Healing zones: Back rows heal pieces once per game
    - Cavalry charge: 2x damage when attacking after 2-space move
    - Line of sight: Optional rule for archer ranged attacks
    - Range limit: Optional 4-space limit for archers
    
    BATTLE PHASE TURN ORDER (ENFORCED):
    1. Must move a piece first (mandatory)
    2. Can then attack with any piece (optional)
    3. End turn
    
    =============================================================================
    -->
    
    <div class="game-container">
        <h1>6x7 Board Game</h1>
        
        <div class="current-player" id="currentPlayer">Player 1's Turn</div>
        <div class="phase-info" id="phaseInfo">Placement Phase - Turn 1/2</div>
        <div class="placement-counter" id="placementCounter">Pieces placed this turn: 0/4</div>
        <div class="turn-actions" id="turnActions"></div>
        <div class="phase-requirement" id="phaseRequirement"></div>
        <div class="placement-zones">
            Player 1: Top 3 rows | Player 2: Bottom 3 rows<br>
            <button onclick="toggleAI()" id="aiToggle">Enable AI</button>
            <button onclick="toggleLineOfSight()" id="losToggle">Enable Line of Sight</button>
            <button onclick="toggleLimitedRange()" id="rangeToggle">Enable 4-Space Range Limit</button>
        </div>
        <div class="error-message" id="errorMessage"></div>
        
        <div class="piece-counts">
            <div class="player-pieces">
                <h4>Player 1 Remaining:</h4>
                <div id="player1Counts"></div>
            </div>
            <div class="player-pieces">
                <h4>Player 2 Remaining:</h4>
                <div id="player2Counts"></div>
            </div>
        </div>
        
        <div class="piece-selector" id="pieceSelector"></div>
        
        <div class="board" id="board"></div>
        
        <button class="end-turn-btn" id="endTurnBtn" onclick="endTurn()">End Turn</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script>
        /* 
        =============================================================================
        GAME STATE VARIABLES
        =============================================================================
        */
        
        // Core game state
        let currentPlayer = 1;          // Current player (1 or 2)
        let gamePhase = 'placement';    // 'placement' or 'battle'
        let placementTurn = 1;          // Current placement turn (1 or 2)
        let selectedPiece = null;       // Selected piece type during placement
        let selectedCell = null;        // Selected cell coordinates {row, col}
        let board = [];                 // 7x6 game board array
        let piecesPlacedThisTurn = 0;   // Counter for placement phase
        let gameEnded = false;          // Game over flag
        
        // Battle phase turn state (ENFORCED MOVE-FIRST RULE)
        let hasMoved = false;           // Has player moved this turn?
        let hasAttacked = false;        // Has player attacked this turn?
        let mustMoveFirst = true;       // Flag to enforce move-first rule
        
        // Optional game rules
        let isAIEnabled = false;        // AI opponent enabled?
        let lineOfSightEnabled = false; // Line of sight for archers?
        let limitedRangeEnabled = false; // 4-space range limit for archers?
        
        /* 
        =============================================================================
        PIECE DEFINITIONS
        =============================================================================
        */
        
        // Piece type definitions with stats
        const pieceTypes = {
            'General': { symbol: '♔', health: 3 },
            'Cavalry': { symbol: '♘', health: 2 },
            'Heavy Infantry': { symbol: '⚔️', health: 3 },
            'Light Infantry': { symbol: '🗡️', health: 2 },
            'Archer': { symbol: '🏹', health: 2, ammo: 3 }
        };
        
        // Starting piece counts for each player
        const startingPieces = { 'General': 1, 'Cavalry': 2, 'Heavy Infantry': 2, 'Light Infantry': 2, 'Archer': 1 };
        let player1Pieces = {...startingPieces};
        let player2Pieces = {...startingPieces};
        
        /* 
        =============================================================================
        INITIALIZATION FUNCTIONS
        =============================================================================
        */
        
        function initGame() { 
            createBoard(); 
            updateUI(); 
            updatePieceSelector(); 
        }
        
        // Create empty 7x6 board
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            board = [];
            for (let row = 0; row < 7; row++) {
                board[row] = [];
                for (let col = 0; col < 6; col++) {
                    board[row][col] = null;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (row === 3) cell.classList.add('middle-row'); // Middle healing row
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => cellClick(row, col);
                    boardElement.appendChild(cell);
                }
            }
        }
        
        /* 
        =============================================================================
        UI UPDATE FUNCTIONS
        =============================================================================
        */
        
        // Check if player can place piece in specific row (placement phase only)
        function canPlaceInRow(player, row) { 
            return player === 1 ? row <= 2 : row >= 4; 
        }
        
        // Display error message with auto-clear
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            setTimeout(() => errorElement.textContent = '', 3000);
        }
        
        // Main UI update function - handles all display elements
        function updateUI() {
            document.getElementById('currentPlayer').textContent = `Player ${currentPlayer}'s Turn`;
            
            if (gamePhase === 'placement') {
                // Placement phase UI
                document.getElementById('phaseInfo').textContent = `Placement Phase - Turn ${placementTurn}/2`;
                document.getElementById('placementCounter').textContent = `Pieces placed this turn: ${piecesPlacedThisTurn}/4`;
                document.getElementById('placementCounter').style.display = 'block';
                document.getElementById('turnActions').style.display = 'none';
                document.getElementById('phaseRequirement').style.display = 'none';
                
                const endTurnBtn = document.getElementById('endTurnBtn');
                if (piecesPlacedThisTurn === 4) {
                    endTurnBtn.disabled = false;
                    endTurnBtn.textContent = 'End Turn';
                } else {
                    endTurnBtn.disabled = true;
                    endTurnBtn.textContent = `End Turn (${4 - piecesPlacedThisTurn} more needed)`;
                }
            } else {
                // Battle phase UI with move-first enforcement
                document.getElementById('phaseInfo').textContent = 'Battle Phase';
                document.getElementById('placementCounter').style.display = 'none';
                document.getElementById('turnActions').style.display = 'block';
                document.getElementById('turnActions').textContent = `Moved: ${hasMoved ? 'Yes' : 'No'} | Attacked: ${hasAttacked ? 'Yes' : 'No'}`;
                
                // Show phase requirement (MOVE FIRST rule)
                const phaseReq = document.getElementById('phaseRequirement');
                phaseReq.style.display = 'block';
                if (!hasMoved) {
                    phaseReq.textContent = 'You must MOVE a piece before attacking!';
                    phaseReq.style.color = '#ff6600';
                } else if (!hasAttacked) {
                    phaseReq.textContent = 'You can now attack with any piece (optional)';
                    phaseReq.style.color = '#0066cc';
                } else {
                    phaseReq.textContent = 'Turn complete - you may end turn';
                    phaseReq.style.color = '#009900';
                }
                
                document.getElementById('endTurnBtn').disabled = false;
                document.getElementById('endTurnBtn').textContent = 'End Turn';
            }
            updatePieceCounts();
            renderBoard();
        }
        
        // Update piece count display
        function updatePieceCounts() {
            document.getElementById('player1Counts').innerHTML = Object.entries(player1Pieces).map(([type, count]) => `${type}: ${count}`).join('<br>');
            document.getElementById('player2Counts').innerHTML = Object.entries(player2Pieces).map(([type, count]) => `${type}: ${count}`).join('<br>');
        }
        
        // Update piece selector buttons (placement phase only)
        function updatePieceSelector() {
            const selector = document.getElementById('pieceSelector');
            selector.innerHTML = '';
            if (gamePhase === 'placement') {
                const pieces = currentPlayer === 1 ? player1Pieces : player2Pieces;
                Object.entries(pieces).forEach(([type, count]) => {
                    const button = document.createElement('div');
                    button.className = `piece-button ${count === 0 ? 'disabled' : ''}`;
                    button.textContent = `${pieceTypes[type].symbol} ${type} (${count})`;
                    button.onclick = () => selectPieceType(type);
                    if (selectedPiece === type) button.classList.add('selected');
                    selector.appendChild(button);
                });
            }
        }
        
        /* 
        =============================================================================
        PLACEMENT PHASE FUNCTIONS
        =============================================================================
        */
        
        // Select piece type for placement
        function selectPieceType(type) {
            if (gamePhase !== 'placement') return;
            const pieces = currentPlayer === 1 ? player1Pieces : player2Pieces;
            if (pieces[type] === 0) return;
            selectedPiece = type;
            selectedCell = null;
            clearHighlights();
            updatePieceSelector();
        }
        
        // Main cell click handler - routes to appropriate phase function
        function cellClick(row, col) {
            if (gamePhase === 'placement') {
                placePiece(row, col);
            } else {
                battlePhaseClick(row, col);
            }
        }
        
        // Place piece during placement phase
        function placePiece(row, col) {
            if (!selectedPiece) { 
                showError('Please select a piece type first!'); 
                return; 
            }
            if (board[row][col]) { 
                showError('Cell is already occupied!'); 
                return; 
            }
            if (piecesPlacedThisTurn >= 4) { 
                showError('You can only place 4 pieces per turn!'); 
                return; 
            }
            if (!canPlaceInRow(currentPlayer, row)) { 
                showError(`Player ${currentPlayer} can only place pieces in ${currentPlayer === 1 ? 'top 3' : 'bottom 3'} rows!`); 
                return; 
            }
            
            const pieces = currentPlayer === 1 ? player1Pieces : player2Pieces;
            if (pieces[selectedPiece] === 0) { 
                showError('No more pieces of this type available!'); 
                return; 
            }
            
            // Create piece data object
            const pieceData = {
                type: selectedPiece,
                player: currentPlayer,
                health: pieceTypes[selectedPiece].health,
                maxHealth: pieceTypes[selectedPiece].health,
                hasBeenReplenished: false
            };
            
            // Add ammo for archers
            if (selectedPiece === 'Archer') {
                pieceData.ammo = pieceTypes[selectedPiece].ammo;
            }
            
            board[row][col] = pieceData;
            pieces[selectedPiece]--;
            piecesPlacedThisTurn++;
            selectedPiece = null;
            updateUI();
            updatePieceSelector();
        }
        
        /* 
        =============================================================================
        BATTLE PHASE FUNCTIONS (WITH MOVE-FIRST ENFORCEMENT)
        =============================================================================
        */
        
        // Handle cell clicks during battle phase with move-first rule
        function battlePhaseClick(row, col) {
            const piece = board[row][col];
            
            if (!selectedCell) {
                // Select a piece to act with
                if (piece && piece.player === currentPlayer) {
                    selectedCell = {row, col};
                    highlightValidActions(row, col);
                    renderBoard();
                }
            } else {
                // Deselect if clicking same cell
                if (selectedCell.row === row && selectedCell.col === col) {
                    selectedCell = null;
                    clearHighlights();
                    renderBoard();
                    return;
                }
                
                const selectedPiece = board[selectedCell.row][selectedCell.col];
                const canMoveHere = canMove(selectedPiece, selectedCell.row, selectedCell.col, row, col);
                const canAttackHere = canAttack(selectedPiece, selectedCell.row, selectedCell.col, row, col);
                
                // ENFORCE MOVE-FIRST RULE
                if (!piece && canMoveHere) {
                    // Moving to empty cell
                    if (!hasMoved) {
                        movePiece(selectedCell.row, selectedCell.col, row, col);
                        hasMoved = true;
                        showError('Move completed! You can now attack with any piece.');
                    } else {
                        showError('You can only move once per turn!');
                    }
                } else if (piece && piece.player !== currentPlayer && canAttackHere) {
                    // Attacking enemy piece
                    if (!hasMoved) {
                        showError('You must MOVE first before attacking!');
                        selectedCell = null;
                        clearHighlights();
                        renderBoard();
                        return;
                    }
                    if (!hasAttacked) {
                        attackPiece(selectedCell.row, selectedCell.col, row, col);
                        hasAttacked = true;
                    } else {
                        showError('You can only attack once per turn!');
                    }
                } else {
                    showError('Invalid move or attack!');
                }
                
                selectedCell = null;
                clearHighlights();
                updateUI();
            }
        }
        
        /* 
        =============================================================================
        MOVEMENT & ATTACK VALIDATION
        =============================================================================
        */
        
        // Check if piece can move to target location
        function canMove(piece, fromRow, fromCol, toRow, toCol) {
            if (piece.type === 'Cavalry') {
                // Cavalry can move 1-2 spaces in cardinal directions
                const rowDiff = Math.abs(fromRow - toRow);
                const colDiff = Math.abs(fromCol - toCol);
                return (rowDiff <= 2 && colDiff === 0) || (rowDiff === 0 && colDiff <= 2);
            } else {
                // All other pieces move 1 space in cardinal directions
                const distance = Math.abs(fromRow - toRow) + Math.abs(fromCol - toCol);
                return distance === 1;
            }
        }
        
        // Check if piece can attack target location
        function canAttack(piece, fromRow, fromCol, toRow, toCol) {
            const target = board[toRow][toCol];
            if (!target || target.player === piece.player) return false;
            
            if (piece.type === 'Archer') {
                const distance = Math.abs(fromRow - toRow) + Math.abs(fromCol - toCol);
                // Archers can always melee attack adjacent enemies
                if (distance === 1) return true;
                // Ranged attacks require ammo and line of sight
                if (piece.ammo > 0 && (fromRow === toRow || fromCol === toCol)) {
                    if (limitedRangeEnabled && distance > 4) return false;
                    if (lineOfSightEnabled && !hasLineOfSight(fromRow, fromCol, toRow, toCol)) return false;
                    return true;
                }
                return false;
            } else {
                // All other pieces can only attack adjacent enemies
                const distance = Math.abs(fromRow - toRow) + Math.abs(fromCol - toCol);
                return distance === 1;
            }
        }
        
        // Check line of sight for archer ranged attacks
        function hasLineOfSight(fromRow, fromCol, toRow, toCol) {
            if (fromRow === toRow) {
                // Horizontal line of sight
                const startCol = Math.min(fromCol, toCol);
                const endCol = Math.max(fromCol, toCol);
                for (let col = startCol + 1; col < endCol; col++) {
                    if (board[fromRow][col]) return false;
                }
            } else if (fromCol === toCol) {
                // Vertical line of sight
                const startRow = Math.min(fromRow, toRow);
                const endRow = Math.max(fromRow, toRow);
                for (let row = startRow + 1; row < endRow; row++) {
                    if (board[row][fromCol]) return false;
                }
            }
            return true;
        }
        
        /* 
        =============================================================================
        MOVEMENT & ATTACK EXECUTION
        =============================================================================
        */
        
        // Execute piece movement
        function movePiece(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            
            // Handle cavalry charge direction tracking
            if (piece.type === 'Cavalry') {
                const distance = Math.abs(fromRow - toRow) + Math.abs(fromCol - toCol);
                if (distance === 2) {
                    // Store charge direction for bonus damage
                    piece.chargeDirection = {
                        row: toRow - fromRow,
                        col: toCol - fromCol
                    };
                    // Normalize to unit vectors
                    if (piece.chargeDirection.row !== 0) {
                        piece.chargeDirection.row = piece.chargeDirection.row > 0 ? 1 : -1;
                    }
                    if (piece.chargeDirection.col !== 0) {
                        piece.chargeDirection.col = piece.chargeDirection.col > 0 ? 1 : -1;
                    }
                } else {
                    piece.chargeDirection = null;
                }
            }
            
            // Move piece to new location
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            // Check for healing in back rows
            checkForHealing(piece, toRow);
        }
        
        // Check if piece should be healed (back row healing)
        function checkForHealing(piece, row) {
            const shouldHeal = (piece.player === 1 && row === 6) || (piece.player === 2 && row === 0);
            if (shouldHeal && !piece.hasBeenReplenished) {
                piece.health = piece.maxHealth;
                piece.hasBeenReplenished = true;
                if (piece.type === 'Archer') {
                    piece.ammo = pieceTypes['Archer'].ammo;
                }
                const playerName = piece.player === 1 ? 'Player 1' : 'Player 2';
                showError(`${playerName}'s ${piece.type} has been replenished!`);
            }
        }
        
        // Execute attack between pieces
        function attackPiece(attackerRow, attackerCol, targetRow, targetCol) {
            if (gameEnded) return;
            const attacker = board[attackerRow][attackerCol];
            const target = board[targetRow][targetCol];
            if (!target) return;
            
            let damage = 1; // Base damage
            const distance = Math.abs(attackerRow - targetRow) + Math.abs(attackerCol - targetCol);
            
            // Cavalry charge bonus damage
            if (attacker.type === 'Cavalry' && attacker.chargeDirection && distance === 1 && target.type !== 'Heavy Infantry') {
                // Check if attack is in same direction as charge
                const attackDirection = {
                    row: targetRow - attackerRow,
                    col: targetCol - attackerCol
                };
                
                if (attackDirection.row === attacker.chargeDirection.row && 
                    attackDirection.col === attacker.chargeDirection.col) {
                    damage = 2;
                    showError('Cavalry charge! Double damage!');
                }
            }
            
            // Consume archer ammo for ranged attacks
            if (attacker.type === 'Archer' && distance > 1) {
                attacker.ammo--;
            }
            
            const wasGeneral = target.type === 'General';
            target.health -= damage;
            
            // Remove piece if health depleted
            if (target.health <= 0) {
                board[targetRow][targetCol] = null;
                if (wasGeneral) {
                    // Game over - General defeated
                    gameEnded = true;
                    const winner = attacker.player;
                    setTimeout(() => {
                        alert(`Player ${winner} wins! Enemy General defeated!`);
                        if (confirm('Play again?')) location.reload();
                    }, 100);
                }
            }
        }
        
        /* 
        =============================================================================
        VISUAL HIGHLIGHTING FUNCTIONS
        =============================================================================
        */
        
        // Highlight valid moves and attacks for selected piece
        function highlightValidActions(row, col) {
            clearHighlights();
            const piece = board[row][col];
            
            // Highlight valid moves (only if haven't moved yet)
            if (!hasMoved) {
                if (piece.type === 'Cavalry') {
                    // Cavalry movement highlighting
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    directions.forEach(([dr, dc]) => {
                        for (let i = 1; i <= 2; i++) {
                            const newRow = row + (dr * i);
                            const newCol = col + (dc * i);
                            if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6 && !board[newRow][newCol]) {
                                document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`).classList.add('highlighted');
                            }
                        }
                    });
                } else {
                    // Standard movement highlighting
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    directions.forEach(([dr, dc]) => {
                        const newRow = row + dr;
                        const newCol = col + dc;
                        if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6 && !board[newRow][newCol]) {
                            document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`).classList.add('highlighted');
                        }
                    });
                }
            }
            
            // Highlight valid attacks (only if moved and haven't attacked yet, OR if haven't moved yet to show potential)
            if (hasMoved && !hasAttacked) {
                highlightAttackTargets(piece, row, col);
            } else if (!hasMoved) {
                // Show potential attack targets even before moving (for planning)
                highlightAttackTargets(piece, row, col);
            }
        }
        
        // Highlight attack targets for a piece
        function highlightAttackTargets(piece, row, col) {
            if (piece.type === 'Archer') {
                // Archer attack highlighting
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                
                // Adjacent melee attacks
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6) {
                        const target = board[newRow][newCol];
                        if (target && target.player !== piece.player) {
                            const cell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                            cell.classList.add('attack-range');
                        }
                    }
                });
                
                // Ranged attacks (if has ammo)
                if (piece.ammo > 0) {
                    // Horizontal ranged attacks
                    for (let c = 0; c < 6; c++) {
                        if (c !== col && board[row][c] && board[row][c].player !== piece.player) {
                            if (limitedRangeEnabled && Math.abs(col - c) > 4) continue;
                            if (lineOfSightEnabled && !hasLineOfSight(row, col, row, c)) continue;
                            const cell = document.querySelector(`[data-row="${row}"][data-col="${c}"]`);
                            cell.classList.add('attack-range');
                        }
                    }
                    // Vertical ranged attacks
                    for (let r = 0; r < 7; r++) {
                        if (r !== row && board[r][col] && board[r][col].player !== piece.player) {
                            if (limitedRangeEnabled && Math.abs(row - r) > 4) continue;
                            if (lineOfSightEnabled && !hasLineOfSight(row, col, r, col)) continue;
                            const cell = document.querySelector(`[data-row="${r}"][data-col="${col}"]`);
                            cell.classList.add('attack-range');
                        }
                    }
                }
            } else {
                // Standard melee attack highlighting
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                directions.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6) {
                        const target = board[newRow][newCol];
                        if (target && target.player !== piece.player) {
                            const cell = document.querySelector(`[data-row="${newRow}"][data-col="${newCol}"]`);
                            cell.classList.add('attack-range');
                        }
                    }
                });
            }
        }
        
        // Clear all visual highlights
        function clearHighlights() {
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('highlighted', 'selected', 'attack-range');
            });
        }
        
        /* 
        =============================================================================
        BOARD RENDERING FUNCTION
        =============================================================================
        */
        
        // Render all pieces on the board with health bars, ammo, etc.
        function renderBoard() {
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 6; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    const piece = board[row][col];
                    
                    // Highlight selected cell
                    if (selectedCell && selectedCell.row === row && selectedCell.col === col) {
                        cell.classList.add('selected');
                    }
                    
                    if (piece) {
                        // Calculate health percentage for health bar
                        const healthPercentage = (piece.health / piece.maxHealth) * 100;
                        
                        // Add ammo counter for archers
                        let ammoDisplay = '';
                        if (piece.type === 'Archer') {
                            ammoDisplay = `<div class="ammo-counter">${piece.ammo}</div>`;
                        }
                        
                        // Add replenished indicator
                        let replenishedIndicator = '';
                        if (piece.hasBeenReplenished) {
                            replenishedIndicator = '<div class="replenished-indicator">R</div>';
                        }
                        
                        // Render piece with all visual elements
                        cell.innerHTML = `
                            <div class="piece player${piece.player}">
                                <div>${pieceTypes[piece.type].symbol}</div>
                                <div class="health-bar">
                                    <div class="health-fill" style="width: ${healthPercentage}%"></div>
                                </div>
                                ${ammoDisplay}
                                ${replenishedIndicator}
                            </div>
                        `;
                    } else {
                        cell.innerHTML = '';
                    }
                }
            }
        }
        
        /* 
        =============================================================================
        TURN MANAGEMENT FUNCTIONS
        =============================================================================
        */
        
        // End current player's turn
        function endTurn() {
            if (gameEnded) return;
            
            // Validate turn completion for placement phase
            if (gamePhase === 'placement' && piecesPlacedThisTurn !== 4) {
                showError('You must place exactly 4 pieces before ending your turn!');
                return;
            }
            
            // Reset turn state
            selectedPiece = null;
            selectedCell = null;
            clearHighlights();
            hasMoved = false;
            hasAttacked = false;
            
            // Clear cavalry charge directions at end of turn
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 6; col++) {
                    if (board[row][col] && board[row][col].type === 'Cavalry') {
                        board[row][col].chargeDirection = null;
                    }
                }
            }
            
            // Handle phase transitions
            if (gamePhase === 'placement') {
                piecesPlacedThisTurn = 0;
                if (currentPlayer === 1) {
                    currentPlayer = 2;
                } else {
                    currentPlayer = 1;
                    placementTurn++;
                    if (placementTurn > 2) {
                        gamePhase = 'battle';
                        showError('Battle Phase begins! Remember: Move first, then attack!');
                    }
                }
            } else {
                // Battle phase - simple player switch
                currentPlayer = currentPlayer === 1 ? 2 : 1;
            }
            
            updateUI();
            updatePieceSelector();
            
            // Trigger AI turn if enabled
            if (isAIEnabled && currentPlayer === 2 && !gameEnded) {
                setTimeout(aiTurn, 1000);
            }
        }
        
        /* 
        =============================================================================
        GAME OPTION TOGGLES
        =============================================================================
        */
        
        // Toggle AI opponent
        function toggleAI() {
            isAIEnabled = !isAIEnabled;
            document.getElementById('aiToggle').textContent = isAIEnabled ? 'Disable AI' : 'Enable AI';
            if (isAIEnabled && currentPlayer === 2 && !gameEnded) {
                setTimeout(aiTurn, 1000);
            }
        }
        
        // Toggle line of sight rule for archers
        function toggleLineOfSight() {
            lineOfSightEnabled = !lineOfSightEnabled;
            document.getElementById('losToggle').textContent = lineOfSightEnabled ? 'Disable Line of Sight' : 'Enable Line of Sight';
            showError(`Line of Sight ${lineOfSightEnabled ? 'enabled' : 'disabled'}`);
        }
        
        // Toggle range limit rule for archers
        function toggleLimitedRange() {
            limitedRangeEnabled = !limitedRangeEnabled;
            document.getElementById('rangeToggle').textContent = limitedRangeEnabled ? 'Disable Range Limit' : 'Enable 4-Space Range Limit';
            showError(`Archer range ${limitedRangeEnabled ? 'limited to 4 spaces' : 'unlimited'}`);
        }
        
        /* 
        =============================================================================
        AI FUNCTIONS (Updated to follow move-first rule)
        =============================================================================
        */
        
        // Main AI turn function
        function aiTurn() {
            if (gameEnded || currentPlayer !== 2 || !isAIEnabled) return;
            if (gamePhase === 'placement') {
                aiPlacementTurn();
            } else {
                aiBattleTurn();
            }
        }
        
        // AI placement phase behavior
        function aiPlacementTurn() {
            const piecesToPlace = 4 - piecesPlacedThisTurn;
            for (let i = 0; i < piecesToPlace; i++) {
                const availablePieces = Object.entries(player2Pieces).filter(([type, count]) => count > 0);
                if (availablePieces.length === 0) break;
                
                const [pieceType] = availablePieces[Math.floor(Math.random() * availablePieces.length)];
                
                // Find valid placement positions
                const validPositions = [];
                for (let row = 4; row < 7; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (!board[row][col]) {
                            validPositions.push({row, col});
                        }
                    }
                }
                
                if (validPositions.length > 0) {
                    const pos = validPositions[Math.floor(Math.random() * validPositions.length)];
                    const pieceData = {
                        type: pieceType,
                        player: 2,
                        health: pieceTypes[pieceType].health,
                        maxHealth: pieceTypes[pieceType].health,
                        hasBeenReplenished: false
                    };
                    
                    if (pieceType === 'Archer') {
                        pieceData.ammo = pieceTypes[pieceType].ammo;
                    }
                    
                    board[pos.row][pos.col] = pieceData;
                    player2Pieces[pieceType]--;
                    piecesPlacedThisTurn++;
                }
            }
            setTimeout(endTurn, 500);
        }
        
        // AI battle phase behavior (follows move-first rule)
        function aiBattleTurn() {
            const aiPieces = [];
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 6; col++) {
                    if (board[row][col] && board[row][col].player === 2) {
                        aiPieces.push({row, col, piece: board[row][col]});
                    }
                }
            }
            
            if (aiPieces.length === 0) {
                setTimeout(endTurn, 1000);
                return;
            }
            
            // Step 1: AI must move first (enforcing move-first rule)
            let moved = false;
            for (const {row, col, piece} of aiPieces) {
                const moves = findValidMoves(piece, row, col);
                if (moves.length > 0) {
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    movePiece(row, col, move.row, move.col);
                    hasMoved = true;
                    moved = true;
                    break;
                }
            }
            
            // Step 2: After moving, AI can attack
            setTimeout(() => {
                if (moved) {
                    // Look for attack opportunities after movement
                    for (let row = 0; row < 7; row++) {
                        for (let col = 0; col < 6; col++) {
                            const piece = board[row][col];
                            if (piece && piece.player === 2) {
                                const targets = findAttackTargets(piece, row, col);
                                if (targets.length > 0) {
                                    // Prioritize attacking the General
                                    const generalTarget = targets.find(t => board[t.row][t.col].type === 'General');
                                    const target = generalTarget || targets[Math.floor(Math.random() * targets.length)];
                                    attackPiece(row, col, target.row, target.col);
                                    hasAttacked = true;
                                    break;
                                }
                            }
                        }
                        if (hasAttacked) break;
                    }
                }
                setTimeout(endTurn, 1000);
            }, 500);
        }
        
        // Find valid attack targets for AI piece
        function findAttackTargets(piece, row, col) {
            const targets = [];
            
            // Archer ranged attacks
            if (piece.type === 'Archer' && piece.ammo > 0) {
                // Horizontal attacks
                for (let c = 0; c < 6; c++) {
                    if (c !== col && board[row][c] && board[row][c].player !== piece.player) {
                        if (limitedRangeEnabled && Math.abs(col - c) > 4) continue;
                        if (lineOfSightEnabled && !hasLineOfSight(row, col, row, c)) continue;
                        targets.push({row, col: c});
                    }
                }
                // Vertical attacks
                for (let r = 0; r < 7; r++) {
                    if (r !== row && board[r][col] && board[r][col].player !== piece.player) {
                        if (limitedRangeEnabled && Math.abs(row - r) > 4) continue;
                        if (lineOfSightEnabled && !hasLineOfSight(row, col, r, col)) continue;
                        targets.push({row: r, col});
                    }
                }
            }
            
            // Adjacent attacks for all pieces
            const directions = [[-1,0], [1,0], [0,-1], [0,1]];
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6) {
                    const target = board[newRow][newCol];
                    if (target && target.player !== piece.player) {
                        targets.push({row: newRow, col: newCol});
                    }
                }
            }
            return targets;
        }
        
        // Find valid moves for AI piece
        function findValidMoves(piece, row, col) {
            const moves = [];
            if (piece.type === 'Cavalry') {
                // Cavalry movement
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dr, dc] of directions) {
                    for (let i = 1; i <= 2; i++) {
                        const newRow = row + (dr * i);
                        const newCol = col + (dc * i);
                        if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6 && !board[newRow][newCol]) {
                            moves.push({row: newRow, col: newCol});
                        }
                    }
                }
            } else {
                // Standard movement
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (newRow >= 0 && newRow < 7 && newCol >= 0 && newCol < 6 && !board[newRow][newCol]) {
                        moves.push({row: newRow, col: newCol});
                    }
                }
            }
            return moves;
        }
        
        /* 
        =============================================================================
        GAME INITIALIZATION
        =============================================================================
        */
        
        // Start the game
        initGame();
    </script>
</body>
</html>